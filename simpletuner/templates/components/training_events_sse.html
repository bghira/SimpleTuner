<template id="callback-progress-template">
    <div class="card training-progress-card d-none">
        <div class="card-body">
            <div class="d-flex justify-content-between align-items-start">
                <div>
                    <h6 class="card-title mb-1"><i class="fas fa-bolt"></i> Training Progress</h6>
                    <small class="text-muted" data-progress-label>Waiting for updatesâ€¦</small>
                </div>
                <span class="badge bg-secondary" data-progress-status>Idle</span>
            </div>
            <div class="progress mt-3" style="height: 8px;">
                <div class="progress-bar" role="progressbar" data-progress-bar
                     style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
            </div>
            <div class="row mt-3 text-muted small">
                <div class="col-6 col-md-3">
                    <div class="fw-semibold text-dark">Step</div>
                    <div><span data-progress-step>0</span> / <span data-progress-total-steps>0</span></div>
                </div>
                <div class="col-6 col-md-3">
                    <div class="fw-semibold text-dark">Epoch</div>
                    <div><span data-progress-epoch>0</span> / <span data-progress-total-epochs>0</span></div>
                </div>
                <div class="col-6 col-md-3 mt-3 mt-md-0">
                    <div class="fw-semibold text-dark">Loss</div>
                    <div data-progress-loss>N/A</div>
                </div>
                <div class="col-6 col-md-3 mt-3 mt-md-0">
                    <div class="fw-semibold text-dark">Learning Rate</div>
                    <div data-progress-lr>N/A</div>
                </div>
            </div>
        </div>
    </div>
</template>

<script>
(function() {
    const TEMPLATE_ID = 'callback-progress-template';
    const CALLBACK_EVENT_TYPES = ['progress', 'validation', 'job', 'status', 'alert', 'checkpoint', 'debug'];
    const MAX_MANAGER_ATTEMPTS = 10;
    const MANAGER_RETRY_DELAY = 500;

    let progressCard = null;
    let elements = null;
    let activeJobId = null;
    let managerRegistered = false;
    let lastCardUpdate = 0;
    const CARD_UPDATE_THROTTLE = 100; // ms

    function getTrainerStore() {
        if (window.Alpine && typeof window.Alpine.store === 'function') {
            try {
                return window.Alpine.store('trainer');
            } catch (error) {
                console.debug('Unable to access Alpine trainer store', error);
            }
        }
        return null;
    }

    function syncButtonState(isTraining) {
        if (window.trainerMain && window.trainerMain.actions) {
            window.trainerMain.actions.updateButtonStates(isTraining);
            return;
        }

        const validateBtn = document.getElementById('validateBtn');
        const runBtn = document.getElementById('runBtn');
        const cancelBtn = document.getElementById('cancelBtn');

        if (isTraining) {
            if (validateBtn) validateBtn.disabled = true;
            if (runBtn) runBtn.disabled = true;
            if (cancelBtn) cancelBtn.disabled = false;
        } else {
            if (validateBtn) validateBtn.disabled = false;
            if (runBtn) runBtn.disabled = false;
            if (cancelBtn) cancelBtn.disabled = true;
        }
    }

    function emitTrainingStatus(status, detail) {
        const payload = Object.assign({ status }, detail || {});
        window.dispatchEvent(new CustomEvent('training-status', { detail: payload }));
    }

    function setTrainingState(status, detail) {
        const normalized = (status || '').toLowerCase() || 'idle';
        const isActive = ['running', 'starting', 'initializing'].includes(normalized);
        const store = getTrainerStore();
        const payload = Object.assign({}, detail || {});

        if (isActive && payload.job_id) {
            activeJobId = payload.job_id;
        }

        if (!isActive) {
            activeJobId = null;
        }

        if (store) {
            store.isTraining = isActive;
            // Hide progress bars when training stops or starts fresh
            if (!isActive || normalized === 'starting') {
                store.showTrainingProgress = false;
            }
        }

        if (payload.job_id == null && activeJobId) {
            payload.job_id = activeJobId;
        }

        syncButtonState(isActive);
        emitTrainingStatus(normalized, payload);

        if (document && document.body) {
            document.body.dataset.trainingActive = isActive ? 'true' : 'false';
        }
    }

    function ensureCard() {
        // Check if card exists and is still in the DOM
        if (progressCard && document.body.contains(progressCard)) {
            return progressCard;
        }

        // Try to find existing card first before creating new one
        const dockBody = document.querySelector('.event-dock-body');
        if (!dockBody) {
            return null;
        }

        const existingCard = dockBody.querySelector('.training-progress-card');
        if (existingCard) {
            progressCard = existingCard;
            elements = {
                label: progressCard.querySelector('[data-progress-label]'),
                status: progressCard.querySelector('[data-progress-status]'),
                bar: progressCard.querySelector('[data-progress-bar]'),
                step: progressCard.querySelector('[data-progress-step]'),
                totalSteps: progressCard.querySelector('[data-progress-total-steps]'),
                epoch: progressCard.querySelector('[data-progress-epoch]'),
                totalEpochs: progressCard.querySelector('[data-progress-total-epochs]'),
                loss: progressCard.querySelector('[data-progress-loss]'),
                lr: progressCard.querySelector('[data-progress-lr]'),
            };
            return progressCard;
        }

        // Only create new card if one doesn't exist
        const template = document.getElementById(TEMPLATE_ID);
        if (!template) {
            return null;
        }

        const clone = template.content.cloneNode(true);
        dockBody.insertBefore(clone, dockBody.firstChild);
        progressCard = dockBody.querySelector('.training-progress-card');

        if (!progressCard) {
            return null;
        }

        elements = {
            label: progressCard.querySelector('[data-progress-label]'),
            status: progressCard.querySelector('[data-progress-status]'),
            bar: progressCard.querySelector('[data-progress-bar]'),
            step: progressCard.querySelector('[data-progress-step]'),
            totalSteps: progressCard.querySelector('[data-progress-total-steps]'),
            epoch: progressCard.querySelector('[data-progress-epoch]'),
            totalEpochs: progressCard.querySelector('[data-progress-total-epochs]'),
            loss: progressCard.querySelector('[data-progress-loss]'),
            lr: progressCard.querySelector('[data-progress-lr]'),
        };

        return progressCard;
    }

    function clampPercent(value) {
        const num = Number(value || 0);
        if (!Number.isFinite(num)) {
            return 0;
        }
        return Math.max(0, Math.min(100, num));
    }

    function toNumber(value) {
        if (value === null || value === undefined || value === '') {
            return null;
        }
        const num = Number(value);
        return Number.isFinite(num) ? num : null;
    }

    function normalizeProgressPayload(payload) {
        if (window.SSEManager && typeof window.SSEManager.normalizeProgressPayload === 'function') {
            return window.SSEManager.normalizeProgressPayload(payload);
        }

        const progress = payload.progress || {};
        let extras = {};

        if (progress.extra && typeof progress.extra === 'object') {
            extras = Object.assign({}, progress.extra);
        }
        if (payload.extras && typeof payload.extras === 'object') {
            extras = Object.assign({}, extras, payload.extras);
        }

        let state = extras.state || null;
        if (!state && progress.extra && typeof progress.extra.state === 'object') {
            state = progress.extra.state;
        }

        let currentStep = toNumber(progress.current);
        if (currentStep === null && state && state.global_step !== undefined) {
            currentStep = toNumber(state.global_step);
        }
        if (currentStep === null && payload.global_step !== undefined) {
            currentStep = toNumber(payload.global_step);
        }
        if (currentStep === null && extras.current_step !== undefined) {
            currentStep = toNumber(extras.current_step);
        }
        if (currentStep === null && payload.current_step !== undefined) {
            currentStep = toNumber(payload.current_step);
        }

        let totalSteps = toNumber(progress.total);
        if (totalSteps === null && extras.total_steps !== undefined) {
            totalSteps = toNumber(extras.total_steps);
        }
        if (totalSteps === null && extras.total_num_steps !== undefined) {
            totalSteps = toNumber(extras.total_num_steps);
        }
        if (totalSteps === null && payload.total_num_steps !== undefined) {
            totalSteps = toNumber(payload.total_num_steps);
        }
        if (totalSteps === null && state && state.total_num_steps !== undefined) {
            totalSteps = toNumber(state.total_num_steps);
        }
        if (totalSteps === null && extras.max_steps !== undefined) {
            totalSteps = toNumber(extras.max_steps);
        }
        if (totalSteps === null && state && state.max_steps !== undefined) {
            totalSteps = toNumber(state.max_steps);
        }

        let epoch = toNumber(extras.epoch);
        if (epoch === null && state && state.current_epoch !== undefined) {
            epoch = toNumber(state.current_epoch);
        }
        if (epoch === null && payload.current_epoch !== undefined) {
            epoch = toNumber(payload.current_epoch);
        }

        let totalEpochs = toNumber(extras.final_epoch);
        if (totalEpochs === null && extras.total_epochs !== undefined) {
            totalEpochs = toNumber(extras.total_epochs);
        }
        if (totalEpochs === null && extras.total_num_epochs !== undefined) {
            totalEpochs = toNumber(extras.total_num_epochs);
        }
        if (totalEpochs === null && payload.total_num_epochs !== undefined) {
            totalEpochs = toNumber(payload.total_num_epochs);
        }
        if (totalEpochs === null && state && state.final_epoch !== undefined) {
            totalEpochs = toNumber(state.final_epoch);
        }

        let percent = toNumber(progress.percent);
        if (percent === null && currentStep !== null && totalSteps) {
            percent = (currentStep / totalSteps) * 100;
        }

        // Debug logging removed to prevent console spam during training

        let loss = extras.loss !== undefined ? toNumber(extras.loss) : null;
        if (loss === null && extras.train_loss !== undefined) {
            loss = toNumber(extras.train_loss);
        }

        let learningRate = extras.learning_rate !== undefined ? toNumber(extras.learning_rate) : null;
        if (learningRate === null && extras.lr !== undefined) {
            learningRate = toNumber(extras.lr);
        }

        return {
            percentage: clampPercent(percent),
            current_step: currentStep || 0,
            total_steps: totalSteps || 0,
            epoch: epoch || 0,
            total_epochs: totalEpochs || 0,
            loss: loss,
            lr: learningRate,
            label: progress.label || payload.headline || '',
            raw: payload,
        };
    }

    function mapSeverityToBootstrap(severity) {
        switch (String(severity || '').toLowerCase()) {
            case 'success':
                return 'success';
            case 'warning':
                return 'warning';
            case 'danger':
            case 'error':
            case 'critical':
                return 'danger';
            case 'secondary':
            case 'debug':
                return 'secondary';
            default:
                return 'info';
        }
    }

    function syncTrainerProgress(progress, jobId) {
        let targetJobId = jobId || activeJobId;
        const store = getTrainerStore();
        const previous = (store && targetJobId && store.trainingProgress && targetJobId === activeJobId)
            ? store.trainingProgress
            : {};

        if (targetJobId && targetJobId !== activeJobId) {
            activeJobId = targetJobId;
        } else if (!targetJobId && activeJobId) {
            targetJobId = activeJobId;
        }

        // Determine total_steps: prefer new value if valid and >= previous
        // This prevents validation callbacks from overwriting with epoch count
        let finalTotalSteps = previous.total_steps || 0;
        if (progress.total_steps && progress.total_steps > 0) {
            // Only update if new value is >= previous (don't let it decrease)
            if (progress.total_steps >= finalTotalSteps) {
                finalTotalSteps = progress.total_steps;
            }
        }

        // Calculate percentage from steps if we have valid total_steps
        let finalPercent;
        if (finalTotalSteps > 0 && progress.current_step !== null && progress.current_step !== undefined) {
            finalPercent = clampPercent((progress.current_step / finalTotalSteps) * 100);
        } else {
            finalPercent = clampPercent(progress.percentage) || previous.percent || 0;
        }

        const merged = {
            percent: finalPercent,
            step: progress.current_step ?? previous.step ?? 0,
            total_steps: finalTotalSteps,
            epoch: progress.epoch ?? previous.epoch ?? 0,
            loss: progress.loss ?? previous.loss ?? 'N/A',
            learning_rate: progress.lr ?? previous.learning_rate ?? 'N/A',
        };

        // Debug logging removed to prevent console spam

        if (store) {
            store.trainingProgress = merged;
            store.isTraining = true;
        }

        window.dispatchEvent(new CustomEvent('training-progress', { detail: merged }));
        setTrainingState('running', { job_id: targetJobId, progress: merged });
    }

    function setStatus(statusText, severity) {
        const card = ensureCard();
        if (!card || !elements || !elements.status) {
            return;
        }

        const level = mapSeverityToBootstrap(severity);
        elements.status.className = 'badge bg-' + level;
        elements.status.textContent = statusText;
    }

    function updateProgressCard(progress, jobId) {
        // Throttle updates to reduce visual jank
        const now = Date.now();
        if (now - lastCardUpdate < CARD_UPDATE_THROTTLE) {
            return;
        }
        lastCardUpdate = now;

        const card = ensureCard();
        if (!card || !elements) {
            return;
        }

        // Debug logging removed to prevent console spam

        if (card.classList.contains('d-none')) {
            card.classList.remove('d-none');
        }

        const percent = clampPercent(progress.percentage);
        if (elements.bar) {
            const newWidth = `${percent}%`;
            if (elements.bar.style.width !== newWidth) {
                elements.bar.style.width = newWidth;
                elements.bar.setAttribute('aria-valuenow', percent);
            }
        }

        // Only update text content if it has changed
        const labelText = progress.label || 'Training updates';
        if (elements.label && elements.label.textContent !== labelText) {
            elements.label.textContent = labelText;
        }

        const stepText = String(progress.current_step ?? 0);
        if (elements.step && elements.step.textContent !== stepText) {
            elements.step.textContent = stepText;
        }

        const totalStepsText = String(progress.total_steps ?? 0);
        if (elements.totalSteps && elements.totalSteps.textContent !== totalStepsText) {
            elements.totalSteps.textContent = totalStepsText;
        }

        const epochText = String(progress.epoch ?? 0);
        if (elements.epoch && elements.epoch.textContent !== epochText) {
            elements.epoch.textContent = epochText;
        }

        const totalEpochsText = String(progress.total_epochs ?? 0);
        if (elements.totalEpochs && elements.totalEpochs.textContent !== totalEpochsText) {
            elements.totalEpochs.textContent = totalEpochsText;
        }

        const lossText = typeof progress.loss === 'number' ? progress.loss.toFixed(4) : 'N/A';
        if (elements.loss && elements.loss.textContent !== lossText) {
            elements.loss.textContent = lossText;
        }

        const lrText = typeof progress.lr === 'number' ? progress.lr.toExponential(2) : 'N/A';
        if (elements.lr && elements.lr.textContent !== lrText) {
            elements.lr.textContent = lrText;
        }

        setStatus('Running', progress.raw?.severity);
        syncTrainerProgress(progress, jobId);
    }

    function handleCallbackEvent(category, payload) {
        const jobId = payload.job_id || payload.raw?.job_id || activeJobId;
        const messageType = (payload.message_type || '').toLowerCase();

        switch (category) {
            case 'progress': {
                const normalized = normalizeProgressPayload(payload);
                updateProgressCard(normalized, jobId);
                break;
            }
            case 'validation': {
                break;
            }
            case 'alert': {
                const toastLevel = mapSeverityToBootstrap(payload.severity);
                if (toastLevel === 'danger') {
                    setStatus('Error', payload.severity);
                    setTrainingState('error', { job_id: jobId });
                }
                break;
            }
            case 'job':
            case 'status': {
                if (messageType === 'configure_webhook') {
                    setStatus('Starting', payload.severity);
                    setTrainingState('starting', { job_id: jobId });
                } else if (messageType === 'training_status') {
                    // Check the status field for training_status messages
                    const status = (payload.status || '').toLowerCase();
                    if (status === 'training_failed' || status === 'failed' || status === 'error') {
                        setStatus('Failed', 'danger');
                        setTrainingState('error', { job_id: jobId });
                        // Clear stale status messages
                        const trainingStatusEl = document.getElementById('training-status');
                        if (trainingStatusEl) {
                            trainingStatusEl.innerHTML = '';
                        }
                        // Hide progress bars when training fails
                        const store = getTrainerStore();
                        if (store) {
                            store.showTrainingProgress = false;
                        }
                        // Show error message if available
                        if (payload.message && window.showToast) {
                            window.showToast(`Training failed: ${payload.message}`, 'error');
                        }
                    } else {
                        // Other training_status messages (running, etc.)
                        setStatus('Running', payload.severity);
                        setTrainingState('running', { job_id: jobId });
                        const normalized = normalizeProgressPayload(payload);
                        updateProgressCard(normalized, jobId);
                        syncTrainerProgress(normalized, jobId);
                    }
                } else if (messageType === '_train_initial_msg' || messageType === 'train_status') {
                    setStatus('Running', payload.severity);
                    setTrainingState('running', { job_id: jobId });
                    // Clear the "Training Starting" message when training actually starts
                    const trainingStatusEl = document.getElementById('training-status');
                    if (trainingStatusEl && trainingStatusEl.innerHTML.includes('Training Starting')) {
                        trainingStatusEl.innerHTML = '';
                        // Show progress bars only after clearing "Training Starting"
                        const store = getTrainerStore();
                        if (store) {
                            store.showTrainingProgress = true;
                        }
                    }
                    // Update progress card with training data for both message types
                    if (messageType === '_train_initial_msg' || messageType === 'train_status') {
                        const normalized = normalizeProgressPayload(payload);
                        updateProgressCard(normalized, jobId);
                        syncTrainerProgress(normalized, jobId);
                    }
                } else if (messageType === 'training_complete' || messageType === 'run_complete') {
                    setStatus('Completed', 'success');
                    let completionProgress = null;
                    const store = getTrainerStore();
                    if (store && store.trainingProgress) {
                        completionProgress = {
                            ...store.trainingProgress,
                            percent: 100,
                        };
                        store.trainingProgress = completionProgress;
                        window.dispatchEvent(new CustomEvent('training-progress', { detail: completionProgress }));
                        // Hide progress bars after a short delay to let user see 100%
                        setTimeout(() => {
                            if (store) {
                                store.showTrainingProgress = false;
                            }
                        }, 3000);
                    }
                    setTrainingState('completed', { job_id: jobId, progress: completionProgress });
                } else if (messageType === 'fatal_error' || messageType === 'exit') {
                    setStatus('Stopped', 'danger');
                    setTrainingState('error', { job_id: jobId });
                    // Clear stale status messages when training fails
                    const trainingStatusEl = document.getElementById('training-status');
                    if (trainingStatusEl) {
                        trainingStatusEl.innerHTML = '';
                    }
                    // Hide progress bars when training stops
                    const store = getTrainerStore();
                    if (store) {
                        store.showTrainingProgress = false;
                    }
                }
                break;
            }
            default: {
                // No-op for generic callbacks
            }
        }
    }

    function trackListener(eventType, callback) {
        registeredListeners.push({ eventType: eventType, callback: callback });
        window.sseManager.addEventListener(eventType, callback);
    }

    function registerManagerListeners() {
        if (managerRegistered) {
            return true;
        }

        if (!window.sseManager || typeof window.sseManager.addEventListener !== 'function') {
            return false;
        }

        var connectionStatusHandler = function(info) {
            if (!info) return;
            if (info.status === 'connected') {
                setStatus('Connected', 'success');
            } else if (info.status === 'reconnecting') {
                setStatus('Reconnecting', 'warning');
            } else if (info.status === 'disconnected') {
                setStatus('Disconnected', 'secondary');
                setTrainingState('idle', { job_id: activeJobId });
                // Clear "Training Starting" message when connection is lost
                const trainingStatusEl = document.getElementById('training-status');
                if (trainingStatusEl) {
                    trainingStatusEl.innerHTML = '';
                }
            }
        };
        trackListener('connection-status', connectionStatusHandler);

        var trainingProgressHandler = function(data) {
            const jobId = data.raw?.job_id || activeJobId;
            const normalized = normalizeProgressPayload(data);
            updateProgressCard(normalized, jobId);
        };
        trackListener('training_progress', trainingProgressHandler);

        var validationCompleteHandler = function(_data) {};
        trackListener('validation_complete', validationCompleteHandler);

        var notificationHandler = function(_data) {};
        trackListener('notification', notificationHandler);

        var errorHandler = function(data) {
            setStatus('Error', 'danger');
            setTrainingState('error', { job_id: activeJobId });
        };
        trackListener('error', errorHandler);

        CALLBACK_EVENT_TYPES.forEach(function(category) {
            var callbackHandler = function(payload) {
                handleCallbackEvent(category, payload);
            };
            trackListener('callback:' + category, callbackHandler);
        });

        managerRegistered = true;
        return true;
    }

    function connectFallbackSSE() {
        const apiBaseUrl = window.ServerConfig?.apiBaseUrl || '';
        const source = new EventSource(`${apiBaseUrl}/api/events`);

        source.addEventListener('message', function(event) {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'training_progress') {
                    const normalized = normalizeProgressPayload({ progress: data });
                    updateProgressCard(normalized, activeJobId);
                }
            } catch (error) {
                console.error('Failed to parse SSE message', error);
            }
        });

        CALLBACK_EVENT_TYPES.forEach(function(category) {
            source.addEventListener('callback:' + category, function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleCallbackEvent(category, data);
                } catch (error) {
                    console.error('Failed to parse callback event', error);
                }
            });
        });

        managerRegistered = true;
    }

    function waitForManager(attempt) {
        if (registerManagerListeners()) {
            return;
        }
        if (attempt >= MAX_MANAGER_ATTEMPTS) {
            connectFallbackSSE();
            return;
        }
        setTimeout(() => waitForManager(attempt + 1), MANAGER_RETRY_DELAY);
    }

    var registeredListeners = [];

    window.initSSE = function() {
        waitForManager(0);
    };

    window.closeSSE = function() {
        // Clean up all registered listeners
        if (window.sseManager && typeof window.sseManager.removeEventListener === 'function') {
            registeredListeners.forEach(function(item) {
                window.sseManager.removeEventListener(item.eventType, item.callback);
            });
            registeredListeners = [];
        }
        setTrainingState('idle', { job_id: activeJobId });
        managerRegistered = false;
    };

    // Clean up on page unload
    window.addEventListener('beforeunload', function() {
        window.closeSSE();
    });

    // Check training status on page load
    async function checkInitialTrainingStatus() {
        try {
            const response = await fetch('/api/training/status');
            if (!response.ok) return;

            const data = await response.json();

            // If training is active, initialize the progress card
            if (data.status === 'running' || data.status === 'starting') {
                const card = ensureCard();
                if (card && data.progress) {
                    // Update progress immediately (normalize first)
                    const normalized = normalizeProgressPayload(data.progress);
                    updateProgressCard(normalized, data.job_id);
                    card.classList.remove('d-none');
                }

                // Set training state
                if (data.job_id) {
                    activeJobId = data.job_id;
                    setTrainingState(data.status === 'running' ? 'running' : 'starting', { job_id: data.job_id });

                    // Update status badge
                    if (elements && elements.status) {
                        const statusText = data.status === 'running' ? 'Running' : 'Starting';
                        setStatus(statusText, 'info');
                    }
                }
            }
        } catch (error) {
            console.debug('Could not fetch initial training status:', error);
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        if (document && document.body && !document.body.dataset.trainingActive) {
            document.body.dataset.trainingActive = 'false';
        }

        // Check if training is already running
        checkInitialTrainingStatus();

        waitForManager(0);
    });
})();
</script>

<style>
.training-progress-card {
    border: 1px solid var(--glass-border, rgba(255, 255, 255, 0.08));
    background-color: var(--card-bg, rgba(255, 255, 255, 0.02));
    box-shadow: var(--shadow-card, 0 4px 12px rgba(0, 0, 0, 0.4));
    border-radius: var(--radius-lg, 12px);
    margin-bottom: 1rem;
}

.training-progress-card .card-body {
    background-color: transparent;
}

.training-progress-card .progress {
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: var(--radius-sm, 4px);
}

.training-progress-card .progress-bar {
    transition: width 0.4s ease;
    background: var(--primary-gradient, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
}

/* Override Bootstrap text color classes for dark theme */
.training-progress-card .text-dark {
    color: var(--text-primary, #ffffff) !important;
}

.training-progress-card .text-muted {
    color: var(--text-secondary, #94a3b8) !important;
}

.training-progress-card .card-title {
    color: var(--text-primary, #ffffff);
}
</style>
