<template id="callback-progress-template">
    <div class="card training-progress-card d-none">
        <div class="card-body">
            <div class="d-flex justify-content-between align-items-start">
                <div>
                    <h6 class="card-title mb-1"><i class="fas fa-bolt"></i> Training Progress</h6>
                    <small class="text-muted" data-progress-label>Waiting for updatesâ€¦</small>
                </div>
                <span class="badge bg-secondary" data-progress-status>Idle</span>
            </div>
            <div class="progress mt-3" style="height: 8px;">
                <div class="progress-bar" role="progressbar" data-progress-bar
                     style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
            </div>
            <div class="row mt-3 text-muted small">
                <div class="col-6 col-md-3">
                    <div class="fw-semibold text-dark">Step</div>
                    <div><span data-progress-step>0</span> / <span data-progress-total-steps>0</span></div>
                </div>
                <div class="col-6 col-md-3">
                    <div class="fw-semibold text-dark">Epoch</div>
                    <div><span data-progress-epoch>0</span> / <span data-progress-total-epochs>0</span></div>
                </div>
                <div class="col-6 col-md-3 mt-3 mt-md-0">
                    <div class="fw-semibold text-dark">Loss</div>
                    <div data-progress-loss>N/A</div>
                </div>
                <div class="col-6 col-md-3 mt-3 mt-md-0">
                    <div class="fw-semibold text-dark">Learning Rate</div>
                    <div data-progress-lr>N/A</div>
                </div>
            </div>
        </div>
    </div>
</template>

<script>
(function() {
    const TEMPLATE_ID = 'callback-progress-template';
    const CALLBACK_EVENT_TYPES = ['progress', 'validation', 'job', 'status', 'alert', 'checkpoint', 'debug'];
    const MAX_MANAGER_ATTEMPTS = 10;
    const MANAGER_RETRY_DELAY = 500;

    let progressCard = null;
    let elements = null;
    let activeJobId = null;
    let managerRegistered = false;
    let lastCardUpdate = 0;
    const CARD_UPDATE_THROTTLE = 100; // ms
    const startupStages = new Map();
    let startupJobId = null;
    const completedJobIds = new Set();
    let lastResetJobId = null;
    let suppressAnonymousProgress = false;

    function getTrainerStore() {
        if (window.Alpine && typeof window.Alpine.store === 'function') {
            try {
                return window.Alpine.store('trainer');
            } catch (error) {
                console.debug('Unable to access Alpine trainer store', error);
            }
        }
        return null;
    }

    function syncButtonState(isTraining) {
        if (window.trainerMain && window.trainerMain.actions) {
            window.trainerMain.actions.updateButtonStates(isTraining);
            return;
        }

        const validateBtn = document.getElementById('validateBtn');
        const runBtn = document.getElementById('runBtn');
        const cancelBtn = document.getElementById('cancelBtn');

        if (isTraining) {
            if (validateBtn) validateBtn.disabled = true;
            if (runBtn) runBtn.disabled = true;
            if (cancelBtn) cancelBtn.disabled = false;
        } else {
            if (validateBtn) validateBtn.disabled = false;
            if (runBtn) runBtn.disabled = false;
            if (cancelBtn) cancelBtn.disabled = true;
        }
    }

    function emitTrainingStatus(status, detail) {
        const payload = Object.assign({ status }, detail || {});
        window.dispatchEvent(new CustomEvent('training-status', { detail: payload }));
    }

    function setTrainingState(status, detail) {
        const normalized = (status || '').toLowerCase() || 'idle';
        const isActive = ['running', 'starting', 'initializing'].includes(normalized);
        const store = getTrainerStore();
        const payload = Object.assign({}, detail || {});

        if (isActive && payload.job_id) {
            activeJobId = payload.job_id;
            completedJobIds.delete(payload.job_id);
            lastResetJobId = null;
            suppressAnonymousProgress = false;
        }

        if (!isActive) {
            activeJobId = null;
        }

        if (normalized !== 'starting') {
            clearStartupProgress();
        }

        if (store) {
            store.isTraining = isActive;
            // Hide progress bars when training stops or starts fresh
            if (!isActive || normalized === 'starting') {
                store.showTrainingProgress = false;
            }
        }

        if (payload.job_id == null && activeJobId) {
            payload.job_id = activeJobId;
        }

        syncButtonState(isActive);
        emitTrainingStatus(normalized, payload);

        if (document && document.body) {
            document.body.dataset.trainingActive = isActive ? 'true' : 'false';
        }
    }

    function clearStartupProgress() {
        startupStages.clear();
        startupJobId = null;
        const container = document.getElementById('training-status');
        if (!container) {
            return;
        }
        const alert = container.querySelector('.startup-progress-alert');
        if (!alert) {
            return;
        }
        const list = alert.querySelector('.startup-progress-list');
        if (list) {
            list.remove();
        }
        if (alert.dataset.startupGenerated === 'true') {
            alert.remove();
        }
    }

    function prettifyStageLabel(value) {
        if (!value) return 'Progress';
        return String(value)
            .replace(/[_-]+/g, ' ')
            .replace(/\b\w/g, function(chr) {
                return chr.toUpperCase();
            });
    }

    function resolveProgressTypeFromPayload(rawPayload) {
        if (!rawPayload || typeof rawPayload !== 'object') {
            return '';
        }
        const fromProgress = rawPayload.progress?.extra?.progress_type;
        if (typeof fromProgress === 'string') {
            return fromProgress;
        }
        const fromExtras = rawPayload.extras?.progress_type;
        if (typeof fromExtras === 'string') {
            return fromExtras;
        }
        const topLevel = rawPayload.progress_type;
        return typeof topLevel === 'string' ? topLevel : '';
    }

    function renderStartupProgress() {
        const container = document.getElementById('training-status');
        if (!container) {
            return;
        }

        let alert = container.querySelector('.startup-progress-alert');
        if (!alert) {
            const existing = container.querySelector('.alert');
            if (existing) {
                alert = existing;
            }
        }

        if (startupStages.size === 0) {
            if (alert) {
                const list = alert.querySelector('.startup-progress-list');
                if (list) {
                    list.remove();
                }
                if (alert.dataset.startupGenerated === 'true') {
                    alert.remove();
                }
            }
            return;
        }

        if (!alert) {
            alert = document.createElement('div');
        }

        alert.classList.add('alert', 'alert-info', 'startup-progress-alert');
        if (alert.dataset.startupGenerated !== 'true') {
            alert.dataset.startupGenerated = 'true';
            alert.innerHTML = '';
        }
        if (!container.contains(alert)) {
            container.appendChild(alert);
        }

        let header = alert.querySelector('.startup-progress-header');
        if (!header) {
            header = document.createElement('div');
            header.className = 'd-flex align-items-center mb-2 startup-progress-header';
            alert.insertBefore(header, alert.firstChild);
        } else {
            header.innerHTML = '';
        }

        const icon = document.createElement('i');
        icon.className = 'fas fa-cog fa-spin me-2';
        header.appendChild(icon);

        const title = document.createElement('strong');
        title.textContent = 'Initialising';
        header.appendChild(title);

        if (startupJobId) {
            let jobInfo = alert.querySelector('[data-startup-job]');
            if (!jobInfo) {
                jobInfo = document.createElement('p');
                jobInfo.className = 'mb-2 small text-muted';
                jobInfo.dataset.startupJob = 'true';
            }
            jobInfo.textContent = `Job ID: ${startupJobId}`;
            alert.insertBefore(jobInfo, header.nextSibling);
        } else {
            const jobInfo = alert.querySelector('[data-startup-job]');
            if (jobInfo) {
                jobInfo.remove();
            }
        }

        let listEl = alert.querySelector('.startup-progress-list');
        if (!listEl) {
            listEl = document.createElement('div');
            listEl.className = 'startup-progress-list';
            alert.appendChild(listEl);
        }

        listEl.innerHTML = '';

        startupStages.forEach((stage, type) => {
            const stageWrapper = document.createElement('div');
            stageWrapper.className = 'startup-progress-item mb-2';

            const header = document.createElement('div');
            header.className = 'd-flex justify-content-between align-items-center mb-1';

            const title = document.createElement('span');
            title.className = 'fw-semibold';
            const keyText = String(type || '');
            const baseLabel = stage.label && stage.label !== keyText ? stage.label : null;
            const displayLabel = baseLabel || prettifyStageLabel(keyText);
            title.textContent = displayLabel;
            if (!baseLabel) {
                const suffix = document.createElement('span');
                suffix.className = 'text-muted small ms-2';
                suffix.textContent = `(${keyText})`;
                title.appendChild(suffix);
            }

            const badge = document.createElement('span');
            badge.className = 'badge bg-info text-dark';
            badge.textContent = `${Math.round(clampPercent(stage.percent))}%`;

            header.appendChild(title);
            header.appendChild(badge);
            stageWrapper.appendChild(header);

            const progressOuter = document.createElement('div');
            progressOuter.className = 'progress progress-sm';

            const bar = document.createElement('div');
            bar.className = 'progress-bar progress-bar-striped progress-bar-animated';
            bar.setAttribute('role', 'progressbar');
            bar.style.width = `${clampPercent(stage.percent)}%`;
            bar.setAttribute('aria-valuenow', stage.current || 0);
            bar.setAttribute('aria-valuemin', '0');
            bar.setAttribute('aria-valuemax', stage.total || 100);

            progressOuter.appendChild(bar);
            stageWrapper.appendChild(progressOuter);

            listEl.appendChild(stageWrapper);
        });
    }

    function handleStartupProgressUpdate(data) {
        if (!data) {
            return;
        }

        if (data.job_id && startupJobId && data.job_id !== startupJobId) {
            clearStartupProgress();
        }
        if (data.job_id) {
            startupJobId = data.job_id;
        }

        const key = String(data.progress_type || data.label || `stage_${startupStages.size}`);
        const stagePercent = clampPercent(data.percent);
        const stageData = {
            label: data.label || key,
            percent: Math.round(stagePercent),
            current: Number(data.current || 0),
            total: Number(data.total || 0),
        };

        if (stageData.percent >= 100 || (stageData.total > 0 && stageData.current >= stageData.total)) {
            startupStages.delete(key);
        } else {
            startupStages.set(key, stageData);
        }

        renderStartupProgress();

        const store = getTrainerStore();
        if (!store || store.showTrainingProgress) {
            return;
        }

        if (startupStages.size === 0) {
            return;
        }

        let totalWeight = 0;
        let sumCurrent = 0;
        let averagePercent = 0;
        let count = 0;

        startupStages.forEach((stage) => {
            count += 1;
            averagePercent += stage.percent;
            if (stage.total > 0) {
                totalWeight += stage.total;
                sumCurrent += stage.current;
            }
        });

        let percent = 0;
        if (totalWeight > 0) {
            percent = Math.round(clampPercent((sumCurrent / totalWeight) * 100));
        } else if (count > 0) {
            percent = Math.round(clampPercent(averagePercent / count));
        }

        store.trainingProgress = Object.assign({}, store.trainingProgress, {
            percent: percent,
            step: sumCurrent || 0,
            total_steps: totalWeight || 0,
            epoch: 0,
            total_epochs: 0,
            loss: 'N/A',
            learning_rate: 'N/A',
        });
        window.dispatchEvent(new CustomEvent('training-progress', { detail: store.trainingProgress }));
    }

    function ensureCard() {
        // Check if card exists and is still in the DOM
        if (progressCard && document.body.contains(progressCard)) {
            return progressCard;
        }

        // Try to find existing card first before creating new one
        const dockBody = document.querySelector('.event-dock-body');
        if (!dockBody) {
            return null;
        }

        const existingCard = dockBody.querySelector('.training-progress-card');
        if (existingCard) {
            progressCard = existingCard;
            elements = {
                label: progressCard.querySelector('[data-progress-label]'),
                status: progressCard.querySelector('[data-progress-status]'),
                bar: progressCard.querySelector('[data-progress-bar]'),
                step: progressCard.querySelector('[data-progress-step]'),
                totalSteps: progressCard.querySelector('[data-progress-total-steps]'),
                epoch: progressCard.querySelector('[data-progress-epoch]'),
                totalEpochs: progressCard.querySelector('[data-progress-total-epochs]'),
                loss: progressCard.querySelector('[data-progress-loss]'),
                lr: progressCard.querySelector('[data-progress-lr]'),
            };
            return progressCard;
        }

        // Only create new card if one doesn't exist
        const template = document.getElementById(TEMPLATE_ID);
        if (!template) {
            return null;
        }

        const clone = template.content.cloneNode(true);
        dockBody.insertBefore(clone, dockBody.firstChild);
        progressCard = dockBody.querySelector('.training-progress-card');

        if (!progressCard) {
            return null;
        }

        elements = {
            label: progressCard.querySelector('[data-progress-label]'),
            status: progressCard.querySelector('[data-progress-status]'),
            bar: progressCard.querySelector('[data-progress-bar]'),
            step: progressCard.querySelector('[data-progress-step]'),
            totalSteps: progressCard.querySelector('[data-progress-total-steps]'),
            epoch: progressCard.querySelector('[data-progress-epoch]'),
            totalEpochs: progressCard.querySelector('[data-progress-total-epochs]'),
            loss: progressCard.querySelector('[data-progress-loss]'),
            lr: progressCard.querySelector('[data-progress-lr]'),
        };

        return progressCard;
    }

    function resetTrainingProgressUI(status, jobId) {
        const store = getTrainerStore();
        if (store) {
            store.trainingProgress = {};
            store.isTraining = false;
            store.showTrainingProgress = false;
        }

        if (jobId) {
            completedJobIds.add(jobId);
            lastResetJobId = jobId;
            suppressAnonymousProgress = false;
        } else {
            lastResetJobId = null;
            suppressAnonymousProgress = true;
        }
        activeJobId = null;
        clearStartupProgress();

        if (progressCard) {
            progressCard.classList.add('d-none');
            if (elements && elements.bar) {
                elements.bar.style.width = '0%';
                elements.bar.setAttribute('aria-valuenow', 0);
            }
        }

        const progressContainer = document.getElementById('trainingProgress');
        if (progressContainer) {
            progressContainer.innerHTML = '';
        }

        const progressBars = document.getElementById('progressBars');
        if (progressBars) {
            progressBars.innerHTML = '';
        }

        window.dispatchEvent(new CustomEvent('training-progress', { detail: { reset: true } }));
        setTrainingState(status || 'idle', { job_id: jobId });
    }

    function clampPercent(value) {
        const num = Number(value || 0);
        if (!Number.isFinite(num)) {
            return 0;
        }
        return Math.max(0, Math.min(100, num));
    }

    function toNumber(value) {
        if (value === null || value === undefined || value === '') {
            return null;
        }
        const num = Number(value);
        return Number.isFinite(num) ? num : null;
    }

    function normalizeProgressPayload(payload) {
        if (payload && payload.reset) {
            return { reset: true, status: payload.status, job_id: payload.job_id };
        }
        if (window.SSEManager && typeof window.SSEManager.normalizeProgressPayload === 'function') {
            return window.SSEManager.normalizeProgressPayload(payload);
        }

        const progress = payload.progress || {};
        let extras = {};
        if (progress && typeof progress === 'object' && !Array.isArray(progress) && Object.keys(progress).length === 0) {
            return null;
        }
        const statusLower = String(payload.status || '').toLowerCase();
        if (['failed', 'error', 'cancelled', 'stopped'].includes(statusLower)) {
            return {
                reset: true,
                status: statusLower,
                job_id: payload.job_id || progress.job_id,
            };
        }

        if (progress.extra && typeof progress.extra === 'object') {
            extras = Object.assign({}, progress.extra);
        }
        if (payload.extras && typeof payload.extras === 'object') {
            extras = Object.assign({}, extras, payload.extras);
        }

        let state = extras.state || null;
        if (!state && progress.extra && typeof progress.extra.state === 'object') {
            state = progress.extra.state;
        }

        let currentStep = toNumber(progress.current);
        if (currentStep === null && state && state.global_step !== undefined) {
            currentStep = toNumber(state.global_step);
        }
        if (currentStep === null && payload.global_step !== undefined) {
            currentStep = toNumber(payload.global_step);
        }
        if (currentStep === null && extras.current_step !== undefined) {
            currentStep = toNumber(extras.current_step);
        }
        if (currentStep === null && payload.current_step !== undefined) {
            currentStep = toNumber(payload.current_step);
        }

        let totalSteps = toNumber(progress.total);
        if (totalSteps === null && extras.total_steps !== undefined) {
            totalSteps = toNumber(extras.total_steps);
        }
        if (totalSteps === null && extras.total_num_steps !== undefined) {
            totalSteps = toNumber(extras.total_num_steps);
        }
        if (totalSteps === null && payload.total_num_steps !== undefined) {
            totalSteps = toNumber(payload.total_num_steps);
        }
        if (totalSteps === null && state && state.total_num_steps !== undefined) {
            totalSteps = toNumber(state.total_num_steps);
        }
        if (totalSteps === null && extras.max_steps !== undefined) {
            totalSteps = toNumber(extras.max_steps);
        }
        if (totalSteps === null && state && state.max_steps !== undefined) {
            totalSteps = toNumber(state.max_steps);
        }

        let epoch = toNumber(extras.epoch);
        if (epoch === null && state && state.current_epoch !== undefined) {
            epoch = toNumber(state.current_epoch);
        }
        if (epoch === null && payload.current_epoch !== undefined) {
            epoch = toNumber(payload.current_epoch);
        }

        let totalEpochs = toNumber(extras.final_epoch);
        if (totalEpochs === null && extras.total_epochs !== undefined) {
            totalEpochs = toNumber(extras.total_epochs);
        }
        if (totalEpochs === null && extras.total_num_epochs !== undefined) {
            totalEpochs = toNumber(extras.total_num_epochs);
        }
        if (totalEpochs === null && payload.total_num_epochs !== undefined) {
            totalEpochs = toNumber(payload.total_num_epochs);
        }
        if (totalEpochs === null && state && state.final_epoch !== undefined) {
            totalEpochs = toNumber(state.final_epoch);
        }

        let percent = toNumber(progress.percent);
        if (percent === null && currentStep !== null && totalSteps) {
            percent = (currentStep / totalSteps) * 100;
        }

        // Debug logging removed to prevent console spam during training

        let loss = extras.loss !== undefined ? toNumber(extras.loss) : null;
        if (loss === null && extras.train_loss !== undefined) {
            loss = toNumber(extras.train_loss);
        }

        let learningRate = extras.learning_rate !== undefined ? toNumber(extras.learning_rate) : null;
        if (learningRate === null && extras.lr !== undefined) {
            learningRate = toNumber(extras.lr);
        }

        const messageType = String(payload.message_type || '').toLowerCase();
        const progressType = resolveProgressTypeFromPayload(payload);
        const isStartupProgress = messageType === 'progress_update' && progressType.startsWith('init_');
        const normalizedPercent = clampPercent(percent);

        return {
            percentage: isStartupProgress ? Math.round(normalizedPercent) : normalizedPercent,
            current_step: currentStep || 0,
            total_steps: totalSteps || 0,
            epoch: epoch || 0,
            total_epochs: totalEpochs || 0,
            loss: loss,
            lr: learningRate,
            label: progress.label || payload.headline || '',
            raw: payload,
        };
    }

    function mapSeverityToBootstrap(severity) {
        switch (String(severity || '').toLowerCase()) {
            case 'success':
                return 'success';
            case 'warning':
                return 'warning';
            case 'danger':
            case 'error':
            case 'critical':
                return 'danger';
            case 'secondary':
            case 'debug':
                return 'secondary';
            default:
                return 'info';
        }
    }

    function syncTrainerProgress(progress, jobId) {
        let targetJobId = jobId || activeJobId;
        const store = getTrainerStore();
        const previous = (store && targetJobId && store.trainingProgress && targetJobId === activeJobId)
            ? store.trainingProgress
            : {};

        if (targetJobId && targetJobId !== activeJobId) {
            activeJobId = targetJobId;
        } else if (!targetJobId && activeJobId) {
            targetJobId = activeJobId;
        }

        // Determine total_steps: prefer new value if valid and >= previous
        // This prevents validation callbacks from overwriting with epoch count
        let finalTotalSteps = previous.total_steps || 0;
        if (progress.total_steps && progress.total_steps > 0) {
            // Only update if new value is >= previous (don't let it decrease)
            if (progress.total_steps >= finalTotalSteps) {
                finalTotalSteps = progress.total_steps;
            }
        }

        // Calculate percentage from steps if we have valid total_steps
        let finalPercent;
        if (finalTotalSteps > 0 && progress.current_step !== null && progress.current_step !== undefined) {
            finalPercent = clampPercent((progress.current_step / finalTotalSteps) * 100);
        } else {
            finalPercent = clampPercent(progress.percentage) || previous.percent || 0;
        }

        const merged = {
            percent: finalPercent,
            step: progress.current_step ?? previous.step ?? 0,
            total_steps: finalTotalSteps,
            epoch: progress.epoch ?? previous.epoch ?? 0,
            loss: progress.loss ?? previous.loss ?? 'N/A',
            learning_rate: progress.lr ?? previous.learning_rate ?? 'N/A',
        };

        // Debug logging removed to prevent console spam

        if (store) {
            store.trainingProgress = merged;
            store.isTraining = true;
            store.showTrainingProgress = true;
        }

        const messageType = String(progress.raw?.message_type || '').toLowerCase();
        const progressType = resolveProgressTypeFromPayload(progress.raw);
        const isStartupProgress = messageType === 'progress_update' && progressType.startsWith('init_');

        window.dispatchEvent(new CustomEvent('training-progress', { detail: merged }));
        setTrainingState(isStartupProgress ? 'starting' : 'running', { job_id: targetJobId, progress: merged });
    }

    function setStatus(statusText, severity) {
        const card = ensureCard();
        if (!card || !elements || !elements.status) {
            return;
        }

        const level = mapSeverityToBootstrap(severity);
        elements.status.className = 'badge bg-' + level;
        elements.status.textContent = statusText;
    }

    function updateProgressCard(progress, jobId) {
        // Throttle updates to reduce visual jank
        const now = Date.now();
        if (now - lastCardUpdate < CARD_UPDATE_THROTTLE) {
            return;
        }
        lastCardUpdate = now;

        const card = ensureCard();
        if (!card || !elements) {
            return;
        }

        // Debug logging removed to prevent console spam

        if (card.classList.contains('d-none')) {
            card.classList.remove('d-none');
        }

        const percent = clampPercent(progress.percentage);
        const messageType = String(progress.raw?.message_type || '').toLowerCase();
        const progressType = resolveProgressTypeFromPayload(progress.raw);
        const isStartupProgress = messageType === 'progress_update' && progressType.startsWith('init_');
        if (elements.bar) {
            const newWidth = `${percent}%`;
            if (elements.bar.style.width !== newWidth) {
                elements.bar.style.width = newWidth;
                elements.bar.setAttribute('aria-valuenow', percent);
            }
        }

        // Only update text content if it has changed
        const defaultLabel = isStartupProgress ? 'Initialising' : 'Training updates';
        const labelText = progress.label || defaultLabel;
        if (elements.label && elements.label.textContent !== labelText) {
            elements.label.textContent = labelText;
        }

        const stepText = String(progress.current_step ?? 0);
        if (elements.step && elements.step.textContent !== stepText) {
            elements.step.textContent = stepText;
        }

        const totalStepsText = String(progress.total_steps ?? 0);
        if (elements.totalSteps && elements.totalSteps.textContent !== totalStepsText) {
            elements.totalSteps.textContent = totalStepsText;
        }

        const epochText = String(progress.epoch ?? 0);
        if (elements.epoch && elements.epoch.textContent !== epochText) {
            elements.epoch.textContent = epochText;
        }

        const totalEpochsText = String(progress.total_epochs ?? 0);
        if (elements.totalEpochs && elements.totalEpochs.textContent !== totalEpochsText) {
            elements.totalEpochs.textContent = totalEpochsText;
        }

        const lossText = typeof progress.loss === 'number' ? progress.loss.toFixed(4) : 'N/A';
        if (elements.loss && elements.loss.textContent !== lossText) {
            elements.loss.textContent = lossText;
        }

        const lrText = typeof progress.lr === 'number' ? progress.lr.toExponential(2) : 'N/A';
        if (elements.lr && elements.lr.textContent !== lrText) {
            elements.lr.textContent = lrText;
        }

        setStatus(isStartupProgress ? 'Initialising' : 'Running', progress.raw?.severity);
        syncTrainerProgress(progress, jobId);
    }

    function handleCallbackEvent(category, payload) {
        const jobId = payload.job_id || payload.raw?.job_id || activeJobId;
        const messageType = (payload.message_type || '').toLowerCase();
        const store = getTrainerStore();

        if (payload && payload.reset) {
            resetTrainingProgressUI(payload.status || 'idle', jobId);
            return;
        }

        switch (category) {
            case 'progress': {
                if (jobId && completedJobIds.has(jobId)) {
                    return;
                }
                if (!jobId && suppressAnonymousProgress && !(store && store.isTraining)) {
                    return;
                }
                if (jobId && lastResetJobId && lastResetJobId === jobId && !(store && store.isTraining)) {
                    return;
                }
                if (!jobId && !activeJobId && !(store && store.isTraining)) {
                    return;
                }
                const normalized = normalizeProgressPayload(payload);
                if (normalized && normalized.reset) {
                    resetTrainingProgressUI(payload.status || 'idle', jobId);
                    return;
                }
                updateProgressCard(normalized, jobId);
                break;
            }
            case 'validation': {
                break;
            }
            case 'alert': {
                const toastLevel = mapSeverityToBootstrap(payload.severity);
                if (toastLevel === 'danger') {
                    setStatus('Error', payload.severity);
                    setTrainingState('error', { job_id: jobId });
                }
                break;
            }
            case 'job':
            case 'status': {
                if (messageType === 'configure_webhook') {
                    setStatus('Starting', payload.severity);
                    setTrainingState('starting', { job_id: jobId });
                } else if (messageType === 'training_status') {
                    // Check the status field for training_status messages
                    const status = (payload.status || '').toLowerCase();
                    if (['training_failed', 'failed', 'error'].includes(status)) {
                        setStatus('Failed', 'danger');
                        resetTrainingProgressUI('failed', jobId);
                        // Clear stale status messages
                        const trainingStatusEl = document.getElementById('training-status');
                        if (trainingStatusEl) {
                            trainingStatusEl.innerHTML = '';
                        }
                        if (payload.message && window.showToast) {
                            window.showToast(`Training failed: ${payload.message}`, 'error');
                        }
                    } else if (['cancelled', 'stopped'].includes(status)) {
                        setStatus('Stopped', 'warning');
                        resetTrainingProgressUI(status, jobId);
                    } else {
                        // Other training_status messages (running, etc.)
                        setStatus('Running', payload.severity);
                        setTrainingState('running', { job_id: jobId });
                        const normalized = normalizeProgressPayload(payload);
                        if (normalized && normalized.reset) {
                            resetTrainingProgressUI(status, jobId);
                        } else {
                            updateProgressCard(normalized, jobId);
                            syncTrainerProgress(normalized, jobId);
                        }
                    }
                } else if (messageType === '_train_initial_msg' || messageType === 'train_status') {
                    setStatus('Running', payload.severity);
                    setTrainingState('running', { job_id: jobId });
                    // Remove startup alert message once training status updates arrive
                    const trainingStatusEl = document.getElementById('training-status');
                    if (trainingStatusEl) {
                        const startupAlert = trainingStatusEl.querySelector('.startup-progress-alert');
                        if (startupAlert) {
                            trainingStatusEl.innerHTML = '';
                        }
                    }
                    // Ensure the main progress card is visible once training begins
                    const store = getTrainerStore();
                    if (store) {
                        store.showTrainingProgress = true;
                    }
                    // Update progress card with training data for both message types
                    if (messageType === '_train_initial_msg' || messageType === 'train_status') {
                        const normalized = normalizeProgressPayload(payload);
                        if (normalized && normalized.reset) {
                            resetTrainingProgressUI(payload.status || 'idle', jobId);
                        } else {
                            updateProgressCard(normalized, jobId);
                            syncTrainerProgress(normalized, jobId);
                        }
                    }
                } else if (messageType === 'training_complete' || messageType === 'run_complete') {
                    setStatus('Completed', 'success');
                    let completionProgress = null;
                    const store = getTrainerStore();
                    if (store && store.trainingProgress) {
                        completionProgress = {
                            ...store.trainingProgress,
                            percent: 100,
                        };
                        store.trainingProgress = completionProgress;
                        window.dispatchEvent(new CustomEvent('training-progress', { detail: completionProgress }));
                        // Hide progress bars after a short delay to let user see 100%
                        setTimeout(() => {
                            if (store) {
                            store.showTrainingProgress = false;
                            }
                        }, 3000);
                    }
                    if (jobId) {
                        completedJobIds.add(jobId);
                    }
                    setTrainingState('completed', { job_id: jobId, progress: completionProgress });
                } else if (messageType === 'fatal_error' || messageType === 'exit') {
                    setStatus('Stopped', 'danger');
                    resetTrainingProgressUI('failed', jobId);
                }
                break;
            }
            default: {
                // No-op for generic callbacks
            }
        }
    }

    function trackListener(eventType, callback) {
        registeredListeners.push({ eventType: eventType, callback: callback });
        window.sseManager.addEventListener(eventType, callback);
    }

    function registerManagerListeners() {
        if (managerRegistered) {
            return true;
        }

        if (!window.sseManager || typeof window.sseManager.addEventListener !== 'function') {
            return false;
        }

        var connectionStatusHandler = function(info) {
            if (!info) return;
            if (info.status === 'connected') {
                setStatus('Connected', 'success');
            } else if (info.status === 'reconnecting') {
                setStatus('Reconnecting', 'warning');
            } else if (info.status === 'disconnected') {
                setStatus('Disconnected', 'secondary');
                setTrainingState('idle', { job_id: activeJobId });
                // Clear any startup progress message when connection is lost
                const trainingStatusEl = document.getElementById('training-status');
                if (trainingStatusEl) {
                    trainingStatusEl.innerHTML = '';
                }
            }
        };
        trackListener('connection-status', connectionStatusHandler);

        var trainingProgressHandler = function(data) {
            if (data && data.reset) {
                resetTrainingProgressUI(data.status || 'idle', data.job_id || activeJobId);
                return;
            }
            const jobId = data.raw?.job_id || data.job_id || activeJobId;
            const store = getTrainerStore();
            if (jobId && completedJobIds.has(jobId)) {
                return;
            }
            if (jobId && lastResetJobId && lastResetJobId === jobId && !(store && store.isTraining)) {
                return;
            }
            if (!jobId && suppressAnonymousProgress && !(store && store.isTraining)) {
                return;
            }
            const normalized = normalizeProgressPayload(data);
            if (normalized && normalized.reset) {
                resetTrainingProgressUI(data.status || 'idle', jobId);
                return;
            }
            updateProgressCard(normalized, jobId);
        };
        trackListener('training_progress', trainingProgressHandler);

        var startupProgressHandler = function(data) {
            handleStartupProgressUpdate(data);
        };
        trackListener('startup_progress', startupProgressHandler);

        var validationCompleteHandler = function(_data) {};
        trackListener('validation_complete', validationCompleteHandler);

        var notificationHandler = function(_data) {};
        trackListener('notification', notificationHandler);

        var errorHandler = function(data) {
            setStatus('Error', 'danger');
            setTrainingState('error', { job_id: activeJobId });
        };
        trackListener('error', errorHandler);

        CALLBACK_EVENT_TYPES.forEach(function(category) {
            var callbackHandler = function(payload) {
                handleCallbackEvent(category, payload);
            };
            trackListener('callback:' + category, callbackHandler);
        });

        managerRegistered = true;
        return true;
    }

    function connectFallbackSSE() {
        const apiBaseUrl = window.ServerConfig?.apiBaseUrl || '';
        const source = new EventSource(`${apiBaseUrl}/api/events`);

        source.addEventListener('message', function(event) {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'training_progress') {
                    const normalized = normalizeProgressPayload({ progress: data });
                    updateProgressCard(normalized, activeJobId);
                }
            } catch (error) {
                console.error('Failed to parse SSE message', error);
            }
        });

        CALLBACK_EVENT_TYPES.forEach(function(category) {
            source.addEventListener('callback:' + category, function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleCallbackEvent(category, data);
                } catch (error) {
                    console.error('Failed to parse callback event', error);
                }
            });
        });

        managerRegistered = true;
    }

    function waitForManager(attempt) {
        if (registerManagerListeners()) {
            return;
        }
        if (attempt >= MAX_MANAGER_ATTEMPTS) {
            connectFallbackSSE();
            return;
        }
        setTimeout(() => waitForManager(attempt + 1), MANAGER_RETRY_DELAY);
    }

    var registeredListeners = [];

    window.initSSE = function() {
        waitForManager(0);
    };

    window.closeSSE = function() {
        // Clean up all registered listeners
        if (window.sseManager && typeof window.sseManager.removeEventListener === 'function') {
            registeredListeners.forEach(function(item) {
                window.sseManager.removeEventListener(item.eventType, item.callback);
            });
            registeredListeners = [];
        }
        setTrainingState('idle', { job_id: activeJobId });
        clearStartupProgress();
        managerRegistered = false;
    };

    // Clean up on page unload
    window.addEventListener('beforeunload', function() {
        window.closeSSE();
    });

    // Check training status on page load
    async function checkInitialTrainingStatus() {
        try {
            const response = await fetch('/api/training/status');
            if (!response.ok) return;

            const data = await response.json();

            // If training is active, initialize the progress card
            if (data.startup_progress && typeof data.startup_progress === 'object') {
                startupStages.clear();
                Object.entries(data.startup_progress).forEach(([key, stage]) => {
                    if (!stage) return;
                    startupStages.set(key, {
                        label: stage.label || key,
                        percent: clampPercent(stage.percent),
                        current: Number(stage.current || 0),
                        total: Number(stage.total || 0),
                    });
                });
                if (startupStages.size > 0) {
                    startupJobId = data.job_id || startupJobId;
                    renderStartupProgress();
                }
            }

            if (data.status === 'running' || data.status === 'starting') {
                const card = ensureCard();
                if (card && data.progress) {
                    // Update progress immediately (normalize first)
                    const normalized = normalizeProgressPayload(data.progress);
                    updateProgressCard(normalized, data.job_id);
                    card.classList.remove('d-none');
                }

                // Set training state
                if (data.job_id) {
                    activeJobId = data.job_id;
                    setTrainingState(data.status === 'running' ? 'running' : 'starting', { job_id: data.job_id });

                    // Update status badge
                    if (elements && elements.status) {
                        const statusText = data.status === 'running' ? 'Running' : 'Starting';
                        setStatus(statusText, 'info');
                    }
                }
            }
        } catch (error) {
            console.debug('Could not fetch initial training status:', error);
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        if (document && document.body && !document.body.dataset.trainingActive) {
            document.body.dataset.trainingActive = 'false';
        }

        // Check if training is already running
        checkInitialTrainingStatus();

        waitForManager(0);
    });
})();
</script>

<style>
.training-progress-card {
    border: 1px solid var(--glass-border, rgba(255, 255, 255, 0.08));
    background-color: var(--card-bg, rgba(255, 255, 255, 0.02));
    box-shadow: var(--shadow-card, 0 4px 12px rgba(0, 0, 0, 0.4));
    border-radius: var(--radius-lg, 12px);
    margin-bottom: 1rem;
}

.training-progress-card .card-body {
    background-color: transparent;
}

.training-progress-card .progress {
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: var(--radius-sm, 4px);
}

.training-progress-card .progress-bar {
    transition: width 0.4s ease;
    background: var(--primary-gradient, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
}

/* Override Bootstrap text color classes for dark theme */
.training-progress-card .text-dark {
    color: var(--text-primary, #ffffff) !important;
}

.training-progress-card .text-muted {
    color: var(--text-secondary, #94a3b8) !important;
}

.training-progress-card .card-title {
    color: var(--text-primary, #ffffff);
}
</style>
